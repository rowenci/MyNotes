# C++ Keywords

## explicit

explicit用来修饰一个类的构造函数

```c++
class TestExplicit{
public:
    int _i;
    explicit TestExplicit(int i) : _i(i) {}
};
```

如上所示，该类当中有一个构造函数，且构造函数当中只有一个参数。

这个时候，如果不加上explicit关键字，那么该类实例化的方式有如下几种：

```c++
TestExplicit t1 = 10;
TestExplicit t3 = 'c';	// 这个方式是把c这个字符的ASCII码值作为参数赋给_i了
t1 = 20;
t1 = t2;

TestExplicit t2(10);
```

第一、二行实例化方法以及第三、四行赋值的方法就是隐式转换。

在C++中, 如果的构造函数只有一个参数时，那么在编译的时候就会有一个缺省的转换操作：将该构造函数对应数据类型的数据转换为该类对象。

但是，如果加上explicit关键字之后，就只有最后一行的代码不会报错了。因为explicit会禁止隐式转换。

一般上述情况只会发生在只有一个参数的构造函数当中。不过，假如有多个参数，但除了第一个参数以外，其余参数都有默认值的情况下，还是会发生隐式转换。

## using

1. 指定使用的命名空间

```c++
using namespace std;
```

2. 替代typedef

```c++
using T int;
T a = 1;
```

## inline

常规函数调用时，程序跳到函数的起始地址，并在函数结束后返回。对于内联函数，程序程序无需跳到另一个位置处执行，再跳回来，因为编译器会将内联函数的代码替换为函数调用。因此，内联函数的运行速度比普通常规稍快些。

内联函数：
Tip： 只有当函数只有 10 行甚至更少时才将其定义为内联函数.

定义: 当函数被声明为内联函数之后, 编译器会将其内联展开, 而不是按通常的函数调用机制进行调用.
优点: 当函数体比较小的时候, 内联该函数可以令目标代码更加高效. 对于存取函数以及其它函数体比较短, 性能关键的函数, 鼓励使用内联.
缺点: 滥用内联将导致程序变慢. 内联可能使目标代码量或增或减, 这取决于内联函数的大小. 内联非常短小的存取函数通常会减少代码大小, 但内联一个相当大的函数将戏剧性的增加代码大小. 现代处理器由于更好的利用了指令缓存, 小巧的代码往往执行更快。
结论: 一个较为合理的经验准则是, 不要内联超过 10 行的函数. 谨慎对待析构函数, 析构函数往往比其表面看起来要更长, 因为有隐含的成员和基类析构函数被调用!
另一个实用的经验准则: 内联那些包含循环或 switch 语句的函数常常是得不偿失 (除非在大多数情况下, 这些循环或 switch 语句从不被执行).
有些函数即使声明为内联的也不一定会被编译器内联, 这点很重要; 比如虚函数和递归函数就不会被正常内联. 通常, 递归函数不应该声明成内联函数.(递归调用堆栈的展开并不像循环那么简单, 比如递归层数在编译时可能是未知的, 大多数编译器都不支持内联递归函数). 虚函数内联的主要原因则是想把它的函数体放在类定义内, 为了图个方便, 抑或是当作文档描述其行为, 比如精短的存取函数.

## constexpr

constexpr函数指的是在编译的时候就能得到其返回值的函数，也就是说将constexpr函数直接转换成其返回值，因此，constexpr函数都是被隐式地定义为内联函数。使用constexpr关键字来修饰constexpr函数。

我认为，这是一个在编译时就检查常量是否声明正确的关键字。

constexpr函数是指能用于常量表达式的函数，函数的返回值类型以及所有形参的类型都必须是字面值类型，而且函数体中必须有且仅有一条return语句。

## friend

友元函数并不能看做是类的成员函数，它只是个被声明为类友元的普通函数：

(1)、在类里声明一个普通函数，在前面加上friend修饰，那么这个函数就成了该类的友元，可以访问该类的一切成员。

(2)、一个普通函数可以是多个类的友元函数。

(3)、一个类的成员函数也可以是另一个类的友元，从而可以使得一个类的成员函数可以操作另一个类的数据成员。

(4)、整个类也可以是另一个类的友元，该友元也可以称作为友类。友类的每个成员函数都可以访问另一个类的所有成员。

友元声明中声明的函数被视为已使用extern关键字声明。

friend函数是一个不是类成员的函数，但它可以访问类的私有和受保护的成员。友元函数不被视为类成员，它们是获得了特殊访问权限的普通外部函数。友元不在类的范围内除非它们是另一个类的成员，否则不能使用成员选择运算符(.和->)调用它们。friend函数由授予访问权限的类声明。可将friend声明放置在类声明中的任何位置。它不受访问控制关键字的影响。

友元关系不是相互的，除非显示指定。友元关系不能继承。友元关系不可传递。

类的外部，也就是通过实例来访问私有(private)或保护(protected)成员，这是被禁止的。但从实用性来说，的确有时很需要在外部访问，C++增加了一种称之为“友元(friend)”函数的声明，将“特权”赋给一些函数(可以是全局函数，也可以是其它类的成员函数)，使之能够访问该类的私有和保护成员。

友元函数必须在类里面声明，而且友元函数一定不是该类的成员函数。另外，友元函数的声明在派生类无效，除非派生类中再声明一次，当然类型转换为基类时，使用没有任何问题。

4.1声明位置
              友元声明以关键字 friend 开始，它只能出现在类定义中。因为友元 不是类授权的成员，所以它 不受其所在类的声明区域 public private 和 protected 的影响。通常我们选择把所有友元声明组织在一起并放在类头之后。具体放的位置，要看团队的一致风格。

4.2友元利弊
             友元不是类成员，但是它可以通过对象访问类中的私有成员。友元的作用在于提高程序的运行效率，但是，它破坏了类的封装性和隐藏性，使得非成员函数可以访问类的私有成员。不过，类的访问权限确实在某些应用场合显得有些呆板，从而容忍了友元这一特别语法现象。

4.3注意事项
友元关系不能被继承。
友元关系是单向的，不具有交换性。若类 B 是类 A 的友元，类 A 不一定是类 B的友元，要看在类中是否有相应的声明。
友元关系不具有传递性。若类 B 是类 A 的友元，类 C 是 B 的友元，类 C 不一定是类 A 的友元，同样要看类中是否有相应的声明。

## extern

按照语法书的说法，extern一般有如下用途。

修饰全局变量：在声明全局变量的时候使用extern修饰变量，表明该变量定义于其他翻译单元。
修饰全局常量：表明该全局常量拥有外部链接（可以被其他翻译单元发现），否则全局常量默认是只有内部链接，即不可被其他翻译单元发现。
修饰局部变量：表明该局部变量在其他翻译单元中被定义，需要在链接的时候去解析。
修饰一个字符串：形如extern “C” 之类的用法大家肯定见过了，表明后接的代码块（或者后接的声明）使用C语言调用惯例。
修饰一个模板：表明该模板已经在其他翻译单元实例化，不需要在这里实例化。



如果要在多个文件当中使用外部变量，那么只需要在一个文件当中包含该变量的定义，在使用该变量的其他所有文件当中，都必须使用extern来声明这个变量。

```c++
// file01.cpp
extern int cats = 20;
int dogs = 22;
```

```c++
// file02.cpp
extern int cats;
extern int dogs;
```

file01可以不加extern，而如果file02不加的话，那么就没法通过编译。

##  decltype

如果想从表达式的类型来推断出要定义的新变量的类型，可以用decltype

```c++
decltype(f()) sum = x;	// sum的类型就是f函数的返回值类型
```

## union

联合是一种特殊的类，一个union可以有多个数据成员，这些数据成员共同使用同一片存储空间，分配给一个union对象的存储空间至少要能容纳它的最大数据成员。也可以为联合的成员指定长度。通过冒号操作符来实现成员长度的指定。
union不能含有引用类型的成员，默认情况下，union的成员都是公有的，这一点和struct相同。
union既不能继承自其他类，也不能作为基类使用，所以在union中不能含有虚函数。
为union的一个数据成员赋值时会令其它数据成员变成未定义的状态。

匿名union是一个未命名的union，一旦我们定义了一个匿名union，编译器就自动为该union创建一个未命名对象。
