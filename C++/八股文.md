# 八股文

## 智能指针

使用智能指针需要引入"memory"头文件

### auto_ptr

c++98的方案，c11已抛弃。

该类型的智能指针是独占模式的，也就是创建的引用只能由一个该类型的智能指针进行调用。

新创建的auto_ptr会抢占上一个auto_ptr的权限。如果再调用上一个auto_ptr，则会出现内存错误。

### unique_ptr

这种是auto_ptr的替代，如果进行上述的操作，那么编译器就会报错，不会在程序运行时出现内存错误。

### shared_ptr

## C++内存分配情况

| 分类标准                       | 分区数量                                        |
| ------------------------------ | ----------------------------------------------- |
| 两大分区                       | 代码区、数据区                                  |
| 四大分区                       | 代码区、全局区（全局/静态存储区）、栈区、堆区   |
| C语言分区                      | 栈、堆、全局/静态变量区、常量存储区             |
| C++语言分区                    | 栈、堆、自由存储区、全局/静态变量区、常量存储区 |
| 内存模型根据生命周期的不同分区 | 自由存储区、动态区、静态区                      |

![img](https://raw.githubusercontent.com/rowenci/ImagePool/main/img/typorad8935a8fb9aa444ca3029402367a2ba6.png)

1. 堆（heap）

​	由程序员管理，需要⼿动 new malloc delete free 进⾏分配和回收，空间较⼤，但可能会出现内存泄漏和空闲碎⽚的情况。如果程序员没有释放掉，在程序结束时OS会自动回收。涉及的问题：“缓冲区溢出”、“内存泄露”

2. 栈（stack）

​	是那些编译器在需要时分配，在不需要时自动清除的存储区。存放局部变量、函数参数。

​	存放在栈中的数据只在当前函数及下一层函数中有效，一旦函数返回了，这些数据也就自动释放了。

3. 全局/静态存储区（.bss段和.data段）

​	全局和静态变量被分配到同一块内存中。在C语言中，未初始化的放在.bss段中，初始化的放在.data段中；在C++里则不区分了。

4. 常量存储区（.rodata段）

​	存放常量，不允许修改（通过非正当手段也可以修改）

5. 代码区（.text段）

​	存放代码（如函数），不允许修改（类似常量存储区），但可以执行（不同于常量存储区）

根据c/c++对象生命周期不同，c/c++的内存模型有三种不同的内存区域，即

1. 自由存储区，动态区、静态区。
2. 自由存储区：局部非静态变量的存储区域，即平常所说的栈
3. 动态区： 用operator new ，malloc分配的内存，即平常所说的堆
4. 静态区：全局变量 静态变量 字符串常量存在位置

而代码虽然占内存，但不属于c/c++内存模型的一部分

## 指针参数传递和引用参数传递

指针参数传递：本质上还是值传递，指针与普通的变量是一样的。因此，传递到函数当中的指针会创建一个副本，作为一个局部变量被函数进行使用，形参指针变了，实参的指针不会变。

引用参数传递：函数的形参也会被作为局部变量在栈中开辟内存空间，但是这个内存空间当中存放的是放进来的实参变量的地址。函数当中的任何操作都会被处理成间接寻址。

## const和static

static：

1. 修饰局部变量：变量被存放在静态数据区，生命周期直到程序结束。作用域没有改变。
2. 修饰全局变量：改变了作用域范围，由全工程可见变成了本文件可见
3. 修饰函数：同2
4. 修饰类：类中的某个函数被static修饰，说明这个函数属于一类class，而不是某个对象实例。变量也是这样。（对于静态非常量成员变量，只能在类里面进行声明，在类外面进行定义和初始化。）
5. 深耕=



