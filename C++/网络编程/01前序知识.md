# 前序知识

## 网络字节序

小端：数据低位存内存低地址

大端：数据低位存内存高地址

在代码当中，int i = 0x1122 对数据来说，11是低位，22是高位。由此可以推出，在编程语言当中，还是从左往右读的

如果是小端的话，那么11存低地址

如果是大端的话，那么11存高地址



网络字节序转换函数

```c++
uint32_t htonl(uint32_t hostlong);	// htonl （host to network long） 本地转网络 （IP）htonl （host to network long） 本地转网络 （IP）

uint16_t htons(uint16_t hostshort);	// htons （host to network short） 本地转网络 （Port）

uint32_t ntohl(uint32_t netlong);	// ntohl （network to host long） 网络转本地 （IP）

uint16_t ntohs(uint16_t netshort);	// ntohs （netwok to host short） 网络转本地 （Port）
```

由此可知：IP地址是32位，xxx.xxx.xxx.xxx（4 * 8）

端口号共16位，65535



想要从点分十进制转换成网络字节序需要干什么？

192.168.1.11(string) -> atoi -> int -> hotnl -> 网络字节序



这种函数就比较麻烦了，有更加方便的转换函数：

本地字节序转换成网络字节序

```c++
int inet_pton(int af, const char *src, void *dst);
```

af ：ip协议使用的类型(AF_INET, AF_INET6)

src ：ip地址（点分十进制）

dst ：转换后的网络字节序的ip地址的指针

retvalue ：成功返回1，如果src不是有效地址，那么返回0，失败则返回-1



网络字节序转换成本地字节序

```c++
const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);
```

af ：ip协议使用的类型(AF_INET, AF_INET6)

src ：转换前的网络字节序的ip地址的指针

dst ：转换后的本地字节序的ip地址的指针（点分十进制）

size ：dst的大小

retvalue ：成功返回dst，失败返回NULL



## sockaddr数据结构

struct sockaddr的诞生早于ipv4，为了向前兼容，现在sockaddr退化成了（void *）的作用，传递一个地址给函数，至于这个函数是sockaddr_in还是sockaddr_in6，由地址族决定，然后函数内部会将类型强转成为所需要的地址类型。

![image-20230610233539236](https://raw.githubusercontent.com/rowenci/ImagePool/main/img/typora202306102335384.png)

sockaddr_in、sockaddr_in6(internet)、sockaddr_un（本地套接字使用） 对sockaddr进行了细分。

```c++
struct sockaddr_in {
               sa_family_t    sin_family; /* address family: AF_INET */
               in_port_t      sin_port;   /* port in network byte order */
               struct in_addr sin_addr;   /* internet address */
 };
struct in_addr {
               uint32_t       s_addr;     /* address in network byte order */
 };

struct sockaddr_in addr;
addr.sin_family = AF_INET/AF_INET6;
addr.sin_port = htons(9527);
addr.sin_addr.s_addr = htonl(ADDRIN_ANY);
```

