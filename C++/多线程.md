# 多线程

![在这里插入图片描述](https://raw.githubusercontent.com/rowenci/ImagePool/main/img/typora202212072005168.png)

c++11后才有多线程

上述几个是与多线程有关的头文件

## 创建线程

在线程对象创建完成之后，这个新创建的线程就开始执行了。

### thread

创建线程的三种方式：

```c++
1.
std::thread myThread(process);	// 函数形式为 void process()
myThread.join();

2.
std::thread myThread(process(100));	// 函数形式为 void process(int a)
myThread.join()
    
3.
std::thread(process, 100).detach();	// 函数形式为 void process(int a)，直接创建线程，没有名字
```

#### join与detach方式

当线程启动之后，**一定要在和线程相关联的thread被销毁之前，确定以何种方式等待线程执行结束。**

detach：启动的线程自主在后台运行，当前的代码继续往下执行， 不等待新创建的线程结束

join：等待新创建的线程运行完毕之后，才会执行下面的代码

```c++
if(myThread.joinable())
    foo.join()
// 判断是哪种模式
```

### this_thread

this_thread是一个类，有四个功能函数

|    函数     |                      使用                       |            说明            |
| :---------: | :---------------------------------------------: | :------------------------: |
|   get_id    |              this_thread::get_id()              |         获取线程id         |
|    yield    |              this_thread::yield()               | 放弃线程执行，回到就绪状态 |
|  sleep_for  | this_thread::sleep_for(std::chrono::seconds(1)) |          暂停1秒           |
| sleep_until |                      如下                       |      一分钟后执行吗？      |

```c++
using std::chrono::system_clock;
std::time_t tt = system_clock::to_time_t(system_clock::now());
struct std::tm *ptm = std::localtime(&tt);
cout << "waiting for the next minute to begin..." << endl;
++ptm->tm_min;	// 加一分钟
ptm->tm_sec = 0;	// 秒数设置为0
this_thread::sleep_until(system_clock::from_time_t(mktime(ptm)));
```

## mutex

mutex头文件主要声明了与互斥量相关的类

|            类型            |      说明       |
| :------------------------: | :-------------: |
|         std::mutex         | 最基本的mutex类 |
|    std::recursive_mutex    |   递归mutex类   |
|      std::time_mutex       |   定时mutex类   |
| std::recursive_timed_mutex | 定时递归mutex类 |

std::mutex对象提供了独占所有权的特性，不支持递归地对std::mutex对象上锁

std::recursive+_lock则可以递归地对互斥量对象上锁

### lock and unlock

```c++
lock()：资源上锁
unlock()：资源解锁
trylock()：查看是否上锁
    1.未上锁返回false，并加锁
    2.已上锁，返回true
    3.同一个线程已经对它上锁，产生死锁
```

如果是不同的mutex对象，那么就不会涉及到统一资源的竞争问题

### lock_guard

创建lock_guard对象时，将尝试获取提供给它的信号量的所有权。

当离开lock_guard对象的作用域时，lock_guard对象将析构并释放拥有的互斥量

特点：

1. 创建即加锁，作用于结束就自动析构并解锁，无需手动解锁
2. 不能中途解锁，必须等作用于结束
3. 不能复制

### unique_lock

unique_lock是lock_guard的升级版，具有lock_guard的所有功能，同时又具有其他很多方法

特点：

1. 创建时可以不锁定（通过将第二个参数设置为std::defer_lock），而在需要的时候再锁定
2. 可以随时加锁、解锁
3. 作用域规则和lock_guard一样，析构时自动解锁
4. 不可赋值，可以移动
5. 条件变量需要改类型的锁作为参数（此时必须使用unique_lock）

## condition_variable

condition_variable头文件有两个variable类

1. condition_variable

   必须结合unique_lock使用

2. condition_variable_any

   可以使用任何锁

**condition_variable条件变量可以阻塞（wait、wait_for、wait_until）调用的线程直到使用（notify_one或notify_all）通知恢复为止。**

condition_variable是一个类，这个类既有构造函数也有析构函数，使用时需要构造对应的condition_variable对象，调用对象相应的函数来实现上面的功能。

|        类型        |                             说明                             |
| :----------------: | :----------------------------------------------------------: |
| condition_variable |                           构建对象                           |
|      析构函数      |                             删除                             |
|        wait        |                           阻塞线程                           |
|      wait_for      |                      按照时间，阻塞线程                      |
|     wait_until     |                      按照时间，阻塞线程                      |
|     notify_one     | 恢复一个线程，如果有多个线程存在，那么不知道哪个线程被恢复运行 |
|     notify_all     |                         恢复所有线程                         |
|     cv_status      |                这是一个类，表示variable的状态                |

```c++
enum class cv_status {no_timeout, timeout}
```

### wait

当前线程通过调用wait()来对自己进行阻塞，直到另一个线程调用notify来唤醒这个线程。

在线程被阻塞的时候，wait会自动调用unlock来释放锁，使得其余被阻塞在锁竞争上面的线程能够有机会获得锁。

一旦当前线程被notify，wait还是也是自动调用lock来获取锁。这样的话就使当前线程拥有的锁的状态与wait被调用时候相同。

