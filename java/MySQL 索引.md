# MySQL 索引

索引是一种能够对数据库查找功能进行优化的一种数据结构，也就是能够提升查找效率。

索引本身也很大，因为如果是使用B+树来作为索引的数据结构的话，它的叶结点当中会保存着数据或者地址，因此索引本身也会当做一个文件存储在磁盘当中

虽然索引能够提升查询效率，但是同时也会降低数据库中对表的更新操作，我的理解是因为索引需要维护B+树这种数据结构，如果对表进行更新的话，势必需要对B+树进行修改，而对B+树修改的操作是很耗时的。



索引类型：

1. 单值索引：一个索引只包含一个列，一个表可以有多个单列索引
2. 唯一索引：索引列的值必须唯一，但允许有空值
3. 复合索引：索引当中包含了多个字段
4. 主键索引：主键的索引
5. 全文索引：主要用来查找文本中的关键字，而不是直接与索引中的值相比较



数据结构有以下几种：

1. Hash
2. 二叉树
3. B树
4. B+树



SQL语法：

```sql
create:
CREATE [UNIQUE] INDEX indexName ON tableName(columnName(length));
ALTER tableName ADD [UNIQUE] INDEX [indexName] ON (columnName(length));

delete:
DROP INDEX [indexName] ON tableName;

show:
SHOW INDEX FROM tableName
```



那么那些情况需要创建索引呢？

1. 主键是自动建立的一个唯一索引
2. 频繁作为查询条件的字段应该创建索引（也就是where后面的字段）
3. 查询中与其他表关联的字段，外键关系建立索引
4. 频繁更新的字段不适合创建索引，因为需要同时维护索引
5. where条件里用不到的字段不创建索引
6. 单键或组合索引的选择？在高并发情况下倾向创建组合索引
7. 查询中排序的字段，排序字段若通过索引去访问，将会提高排序速度
8. 查询中统计或者分组字段

哪些情况不要创建索引？

1. 表中的记录很少

2. 经常更新的表

3. 数据重复且分布均匀的表字段，如果某个字段包含许多重复内容，为它创建索引就没有太大的效果了

   应该只为最经常查询和最经常排序的字段创建索引





对于MySQL来说，有两套存储引擎，分别是：

1. InnoDB
2. MyISAM



有两种索引，分别是：

1. 聚簇索引

   数据和索引放置在一起存放在叶子结点当中，找到主键之后，直接把数据返回出去了。

2. 非聚簇索引

   数据和索引不放置在一起，叶子结点存储的是主键和一个地址。



MySQL是给唯一键建的索引



最左匹配：在包含多个列的查询过程中，会从左向右先查找第一个列，再查找第二个列

索引下推（ICP）：不使用索引下推的话，先根据name列的值把所有的数据都拉取到server层，再对age做过滤。使用索引下推之后，根据name，age两个字段把满足要求的数据拉取到server层，取出对应的数据（类似于优化关系代数表达式的时候将选择操作尽可能下移到靠近叶结点）

MRR(Multi-Range Read )：在回表的过程当中，如果根据辅助索引查到的id是无序的话，那么根据这个无序的列表查找数据是很慢的，因此，MRR并不是每次通过辅助索引查找到id之后就回表去取记录，而是将其rowid给缓存起来，然后对rowid进行排序后，再去访问记录，这样就能将随机I/O转化为顺序I/O，从而大幅地提升性能



回表：如果创建索引的是其他字段，那么在叶子结点中存储的是该记录的主键，然后通过主键索引找到对应的记录，这个操作叫做回表，不需要经过回表的叫索引覆盖



主索引和辅助索引：主索引就是主键索引，辅助索引就是根据业务需要，自己设置的普通的非主键的索引。这个在Myisam里面区别不大，但是在Innodb的时候差别很大

聚簇索引：Innodb的主索引采用的是聚簇索引，一个表只能有1个聚簇索引，因为表数据存储的物理位置是唯一的。聚簇索引的value存的就是真实的数据，不是数据的地址。主索引树里面包含了真实的数据。key是主键值，value值就是data，key值按照B+树的规则分散排布的叶子节点。

非聚簇索引：Myisam的主索引和辅助索引都采用的是非聚簇索引，索引和表数据是分离的，索引的value值指向的物理的存储地址。

Innodb的索引：主索引采用聚簇索引，叶子节点的value值，直接存储的真实的数据。辅助索引是非聚簇索引，value值指向主索引的位置。所以Innodb中，根据辅助索引查询值需要遍历2次B+树，同时主键的长度越短越好，越短副主索引的value值就越小。但是Innodb中根据主键进行范围查询，会特别快。

Myisam的索引：主索引和辅助索引都是非聚簇索引

B+树：不管是什么索引，在mysql中的数据结构都是B+树的结构，可以充分利用数据块，来减少IO查询的次数，提升查询的效率，如图所示，一个数据块data里面，存储了很多个相邻key的value值，所有的非叶子节点都不存储数据，都是指针。

Mysql采用B+树的优点：IO读取次数少（每次都是页读取），范围查找更快捷（相邻页之间有指针）

下面分别介绍这两种存储引擎的特点



## InnoDB

通过B+树来作为索引的数据结构，在叶子结点当中存储记录

如果没有主键，那么会选择唯一键

如果没有唯一键，那么会生成一个6字节的row_id来作为主键

InnoDB的行锁是建立在索引的基础之上的，行锁锁的是索引，不是数据，所以提高并发写的能力要在查询字段添加索引

一个表只能有1个聚簇索引

## MyISAM

通过B+树来作为索引的数据结构，在叶子结点当中存储记录的地址

找到主键之后通过地址来找到对应的记录



## EXPLAIN

使用EXPLAIN关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理你的SQL语句的，分析你的查询语句或者表结构的性能瓶颈



能干嘛：

1. 查看表的读取顺序
2. 查看数据读取操作的操作类型
3. 哪些索引可以使用
4. 哪些索引被实际使用
5. 表之间的引用
6. 每张表有多少行被优化器查询



使用方法：

```sql
explain [SQL]
```





执行计划包含的信息：

id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra



### id

它是select查询的序列号，包含了一组数字，表示查询中执行select自居或操作表的顺序

有三种情况：

1. id相同，执行顺序由上至下
2. id不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行
3. id相同不同，同时存在，这根据上面两个来看了

### select_type

有6个：![image-20200611215358973](C:\Users\45928\AppData\Roaming\Typora\typora-user-images\image-20200611215358973.png)

主要是查询的类型，主要是用于区别：普通查询、联合查询、子查询、还是嵌套查询等复杂查询

1. SIMPLE：简单的select查询，查询中不包含子查询或者UNION
2. PRIMARY：查询中若包含任何复杂的子部分，则最外层查询被标记为这个
3. SUBQUERY：在SELECT或WHERE列表中包含了子查询
4. DERIVED：在FROM列表中包含的子查询被标记为DERIVED（衍生），MySQL会递归执行这些子查询，把结果放在临时表中，一般后面会跟一个数字，这个数字表示是哪个表衍生出来的，这个数字就是前面的那个id
5. UNION：若第二个SELECT出现在UNION之后，则被标记为UNION，若UNION包含在FROM子句的子查询中，外层SELECT将被标记为：DERIVED
6. UNION RESULT：从UNION表获取结果的SELECT

### type

访问类型，显示查询使用了哪种类型，从好到坏依次是：

system > const > eq_ref > ref > range > index > ALL

 一般来说，得保证查询至少达到range级别，最好能到ref

1. system：表只有一行记录（等于系统表），这是const类型的特列，平时不会出现
2. const：表示通过索引依次就找到了，const用于比较primary key或者unique索引。因为只匹配一行数据，所以很快。如：将主键置于where列表中，MySQL就能将该查询转换成为一个常量时间
3. eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配，常见于主键或唯一索引扫描
4. ref：非唯一性索引扫描，返回匹配某个单独值的所有行，本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而，它可能会找到多个符合条件的行，所以它应该属于查找和扫描的混合体
5. range：值检索给定范围的行，使用一个索引来选择行。key列显示使用了哪个索引。一般就是在你的where语句中出现了between、<、>、in等的查询
6. index：Full Index Scan，index与ALL区别为index类型只遍历索引树，这通常比ALL快，因为索引文件通常比数据文件小。（也就是说虽然ALL和index都是读全表，单index是从索引当中读的）
7. ALL：Full Table Scan，遍历全表找到匹配的行

### possible_key

显示可能应用在这张表中的索引，有一个或多个，查询设计到的字段上若存在索引，则该索引将被列出，**但不一定被查询实际使用**。

### key

实际使用的索引，如果为NULL，则没有使用索引。**查询中若使用了覆盖索引，则该索引仅出现在key列表中**

### key_len

表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。在不损失精确性的情况下，越长越好。

key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算所得，不是通过表内检索得出的。

### ref

显示索引的哪一列被使用了，如果可能的话，是一个常数，哪些列或常量被用于查找索引列上的值

### rows

根据表统计信息及索引选用情况，大致估算出找到所需的记录所需要读取的行数

### Extra

包含不适合在其他列中显示但十分重要的额外信息

1. Using filesort：说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取，MySQL中无法利用索引完成的排序操作成为“文件内排序”
2. Using temporary：使用了临时表保存中间结果，MySQL在对查询结果排序时使用临时表，常见于order by 和分组查询 group
3. Using index：表示相应的select操作中使用了覆盖索引，避免访问了表的数据行。如果同时出现Using where，表明索引被用来执行索引键值的查找。如果没有出现Using where，表明索引用来读取数据，而不是执行查找动作。
4. Using where：使用了where
5. Using join buffer：使用了连接缓存
6. impossible where：where子句的值是false，无法获取元组
7. select tables optimized away：没有GROUP BY的情况下，基于索引优化MIN/MAX操作或者对于MyISAM引擎优化COUNT(*)操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化
8. distinct：优化distinct操作，找到第一匹配的元组之后就停止同值的比较

覆盖索引：select的数据列只用从索引中就能取得，而不需要读数据行，也就是查找的字段和索引的字段完全相同。

## show profiles

MySQL用来分析当前会话中语句执行的资源消耗情况，可以用于SQL调优的测量

默认情况 ，参数处于关闭状态，并且保存最近15次的结果

步骤：

1. 查看当前MySQL版本是否支持：show variables like 'profiling'
2. 开启功能：set profiling = on
3. 运行SQL
4. 查看结果：show profiles
   1. ![image-20200612135124815](C:\Users\45928\AppData\Roaming\Typora\typora-user-images\image-20200612135124815.png)
5. 诊断SQL：show profile cpu,block io for query + 上一步前面的问题SQL数字号码

![image-20200612135705692](C:\Users\45928\AppData\Roaming\Typora\typora-user-images\image-20200612135705692.png)

需要注意的结论：

1. converting HEAP to MyISAM查询结果太大，内存不够就往磁盘上借
2. Creating tmp table 创建临时表
3. Copying to tmp table on disk 将临时表复制到磁盘
4. locked

## 全局查询日志

1.![image-20200612140017270](C:\Users\45928\AppData\Roaming\Typora\typora-user-images\image-20200612140017270.png)



2.

![image-20200612135947447](C:\Users\45928\AppData\Roaming\Typora\typora-user-images\image-20200612135947447.png)

## 数据库锁

手动增加表锁

lock table [tableName] read(write), [tableName2] read(write), ...;

查看表上加过的锁

show open tables;

释放表锁

unlock tables;





索引失效行锁变表锁

例子：索引是一个字段col，通过where col来修改另一个字段，这时，如果col是varchar类型，而如果where后面没有加上单引号，那么这条sql就不会走索引，从而锁的是整个表，其他查询就会被阻塞





间隙锁：当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的所有数据项都加锁，对于键在条件范围内，但是并不存在的记录，叫做间隙（gap）。其实就是范围查询时，突然一个新增数据进来了，而这个新增数据也在查询的范围内，那么这个新增sql就会被阻塞



锁某一行

![image-20200612142008707](C:\Users\45928\AppData\Roaming\Typora\typora-user-images\image-20200612142008707.png)