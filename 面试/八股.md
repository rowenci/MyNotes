# 八股

## 智能指针

管理一个指针，避免程序员为该指针申请的空间忘记释放，造成内存泄漏。

智能指针就是一个类，当超出了类的作用域时，类会自动调用析构函数，释放资源。

智能指针涉及的4个接口

```c++
T* get();	// 获取原生指针
T& operator*();
T* operator->();
T& operator=(const T& val);
T* release();	// 将指针置为nullptr，返回指针置空之前的值
void reset(T* ptr = nullptr);	// 释放内部指针指向的内存，并将指针置为ptr
```

1. auto_ptr：c11已抛弃，采用所有权模式。如果有一个新的auto_ptr引用到旧auto_ptr的内容后，旧auto_ptr的所有权就被剥夺。但如果有访问它的代码时，编译期不会报错，运行期会报错。
2. unique_ptr：用于替换auto_ptr，编译期会报错，不会出现内存崩溃。
3. shared_ptr：共享型，多个智能指针可以指向相同的对象。这个对象会在最后一个引用被销毁时释放。使用计数机制来表明资源被几个指针共享。
4. weak_ptr：弱引用。不控制对象生命周期，且不会引起shared_ptr计数的增减。用于解决shared_ptr相互引用时的死锁问题。

## 内存布局

栈区：由编译器管理分配和回收，存放局部变量和函数参数。

堆区：由程序员进行管理，需要手动使用new delete malloc free进行分配和回收，空间较大。

全局/静态存储区：分为初始化和未初始化两个相邻区域，存储初始化和未初始化的全局变量和静态变量。

常量存储区：存储常量，一般不允许修改。

代码区：存放程序的二进制代码。

![在这里插入图片描述](https://raw.githubusercontent.com/rowenci/ImagePool/main/img/typorae73bceac54ec4d3fb822d619d8896ddb.png)

## new delete malloc free的区别

## 指针参数传递和引用参数传递

指针参数传递：也就是函数的参数是指针。函数内部使用的变量是指针的副本，因为指针被当做一个普通变量被拷贝，由函数内部进行使用

引用参数传递：函数的参数是引用。函数内部对变量的使用会被处理成间接寻址。

## const和static关键字

### static

控制变量的存储方式和可见性。

1. 修饰局部变量：将局部变量的存放从栈区移动到静态存储区，同时将生命周期从代码块变成整个程序执行结束。**但局部静态变量的作用域还是没有改变，依旧是代码块以内。**

2. 修饰全局变量：限制了全局变量的作用域范围，从全工程可见变成了本文件可见。

3. 修饰函数：同全局变量，改变了函数的作用域。静态全局变量和静态函数如果在另一个文件当中用extern定义的话，会报重定义的错误。
4. 修饰类的成员函数：表示该函数属于一个类而不是属于类的任何特定实例。因此static成员函数没有this指针，只能访问类的static成员变量，且不能被virtual修饰。
5. 修饰类的成员变量：表示该变量由类的所有实例所有。（静态非常量数据成员只能在类内进行声明，在类外进行定义）

### const

1. 修饰基本类型变量：变量值无法修改
2. 修饰指针和引用变量：在指针前，修饰的是指针指向的变量。在指针后，修饰的是这个指针。
3. 修饰函数形参：形参无法修改
4. 修饰返回值：返回值无法修改
5. 修饰成员变量：因为类可以创建多个对象，因此不同的对象const成员变量值可以不同，所以不能再类的声明中初始化const成员变量。需要在构造函数的初始化参数列表当中当中对const成员变量进行初始化。
6. 修饰成员函数：防止成员函数修改对象的内容。如果实在想修改，可以使用mutable进行修饰。
7. 修饰类对象：只能调用常量函数，不能调用别的成员函数。（原因：对象调⽤成员函数时，在形 参列表的最前⾯加⼀个形参 this，但这是隐式的。this 指针是默认指向调⽤函数的当前对象的，所以，很自然， this 是⼀个常量指针 test * const，因为不可以修改 this 指针代表的地址。但当成员函数的参数列表（即小括号） 后加了 const 关键字（void print() const;），此成员函数为常ᰁ成员函数，此时它的隐式this形参为 const test * const，即不可以通过 this 指针来改变指向对象的值。）

## C和C++的区别

c++有新的语法和关键字

C++有重载和虚函数

C的struct和C++的类也不同

C++还有模板和stl

## C++常量放在内存哪部分？

局部常量：栈区

全局常量：编译期一般不分配内存，放在符号表中以提高访问效率

字面值常量，比如字符串，放在常量区。

## C++所有的构造函数

1. 无参构造函数：默认构造函数，没有参数，编译期会自动生成。
2. 一般构造参数：或重载构造函数，可以有各种参数形式，一个类可以有多个一般构造函数。根据创建对象时传入的参数来进行调用。
3. 拷贝构造函数：函数参数为对象本身的引用，用于根据一个已存在的对象复制出一个新的该类的对象。一般在函数中会将所有数据成员一一复制到新创建的对象当中。如果没有显式地写拷贝构造函数，系统同样会默认创建一个。如果类中有指针成员，最好自己定义并进行深拷贝。
4. 类型转换构造函数：根据一个指定类型的对象创建一个本类的对象。
5. 赋值运算符重载：类似拷贝构造函数。

## 四种强制转换

1. static_cast：明确指出类型转换。
2. dynamic_cast：专门用于派生类之间的转换
3. const_cast：专门用于const属性的转换，去除或增加const行之
4. reinterpret_cast：从底层对数据进⾏新解 释，依赖具体的平台，可移植性差； 可以将整形转 换为指针，也可以把指针转换为数组；可以在指针和引⽤ 之间进⾏肆⽆忌惮的转换。

