# 计算机网络

## 基础

| TCP/IP四层模型 | OSI七层模型 | 五层模型   |
| -------------- | ----------- | ---------- |
| 应用层         | 应用层      | 应用层     |
|                | 表示层      |            |
|                | 会话层      |            |
| 传输层         | 传输层      | 传输层     |
| 网络层         | 网络层      | 网络层     |
| 网络接口层     | 数据链路层  | 数据链路层 |
|                | 物理层      | 物理层     |

![image-20230313110643103](https://raw.githubusercontent.com/rowenci/ImagePool/main/img/typoraimage-20230313110643103.png)

![image-20230313110658365](https://raw.githubusercontent.com/rowenci/ImagePool/main/img/typoraimage-20230313110658365.png)

### 应用层

日常使用的app即是在应用层进行实现的。

应用层协议：HTTP、FTP、Telnet、DNS、SMTP等

应用层工作在OS的用户态，传输层及以下工作在内核态

### 传输层

传输层提供的是端到端的通信，也就是端口到端口（Port）。

传输层协议：TCP、UDP

传输层的协议数据单元（PDU）：报文

### 网络层

网络层主要负责传输层传递过来的数据是如何在网络当中进行传输的，也就是如何在路由器之间进行跳转。

网络层协议：IP

网络层的协议数据单元：分组

### 数据链路层

数据链路层负责相邻节点的数据传输。也就是局域网当中的数据传输，为网络层提供服务。主要是MAC啥的。

数据链路层协议：GBN、SR、ALOHA、CSMA、CSMA/CD、CSMA/CA

数据链路层PDU：帧

### 物理层

物理层负责比特流的传输，数据链路层的数据传到物理层，由物理层的链路来进行传输

有标准，不用记。

比较重要的可能是曼彻斯特编码、差分曼彻斯特编码等。

物理层PDU：比特

## 数据链路层

### 功能

在物理层服务的基础上，为网络层提供服务。加强物理层传输原始比特流的功能，将物理层提供的可能出错的物理连接改为逻辑上无差错的数据链路，使之对网络层表现为一条无差错的链路。



该层上有流量控制、可靠传输与滑动窗口机制

1. 停止-等待流量控制：发送方发送一帧就得等待接收方的应答信号，之后才能发送下一帧
2. 滑动窗口流量控制：在发送窗口内的才能进行发送

### 协议

#### 单帧滑动窗口与停等协议

滑动窗口大小为1

发一个、收一个确认帧

#### 多帧滑动窗口与后退N帧协议（GBN）

GBN接收窗口为1

发送窗口[1, 2的n次方 - 1]

#### 多帧滑动窗口与选择重传协议（SR）

可以只重传出错的帧或者计时器超时的帧。

在计时器超时或接收方怀疑帧出错时，就会发送否定帧NAK给发送方。

### 介质访问控制

1. 频分复用FDM
2. 时分复用TDM
3. 波分复用WDM
4. 码分复用CDM

#### 随机访问介质访问控制

##### ALOHA协议

纯ALOHA协议：网络中的站点如果需要发送数据，可以直接进行访问。如果一段时间内没有收到确认，那么就等待一段时间后重发。

时隙ALOHA协议：网络中各站在时间上同步起来，只有在每个时隙开始时才能发送帧。之后的过程与纯ALOHA一样。

##### CSMA协议

载波监听多路访问（carrier sense multiple access）

1-坚持CSMA

如果要发数据，首先监听信道，如果空闲立即发，否则监听至信道空闲。

1-坚持：持续监听，空闲后发送帧的概率为1



非坚持CSMA：信道忙时放弃监听，随机等待时间后再监听



p-坚持CSMA：空闲后以p的概率发送数据

##### CSMA/CD协议

载波监听多路访问/碰撞检测（carrier sense multiple access with collision detection）

适用于总线型或半双工网络环境

先听后发，边听边发，冲突停发，随机重发。

因为电磁波在总线上的传播速度是有限的，因此如果发送站监听到空闲，总线却不一定是空闲的。

如果τ为单程传播时延，那么之多经过2τ时间，发送站就能知道发送的帧有没有发送碰撞。2τ也成为争用期。在这个时间段内还没有检测到碰撞时，才能确定这次发送不会发生碰撞。

最小帧长 = 总线传播时延 * 数据传输速率 * 2

Ethernet规定51.2微秒为争用期长度。对于10Mb/s的以太网，如果前64B数据没有发生冲突，那么后续数据也不会发生冲突。

在监测到碰撞后，执行**二进制指数退避算法**来解决碰撞问题

1. 确定基本退避时间，一般取2τ
2. 定义重传次数k = min[重传次数，10]
3. 从[0, 1, ... , 2的k次方 - 1]中取一个数r。基本退避时间就是2rτ
4. 重传16次仍然没有成功时，说明网络拥挤，向高层报告出错。

##### CSMA/CA协议

碰撞避免（collision avoidance）

用于802.11无线局域网

##### 轮询访问：令牌传递

空闲时，令牌在总线上传递，谁拿到令牌谁才能发数据

### 以太网

IEEE 802.3是一种基带总线型的局域网标准

每块网卡当中的MAC地址也称为物理地址。

MAC地址长6B如：02-60-8c-e4-b1-21

以太网MAC帧：

![image-20230325111026373](https://raw.githubusercontent.com/rowenci/ImagePool/main/img/typoraimage-20230325111026373.png)

### 广域网

#### PPP协议

PPP（Point to Point Protocol）是使用串行线路通信的面向字节的协议。应用在直接连接两个结点的链路上。

设计的主要目的是通过拨号或专线方式建立点对点连接发送数据。

PPP有三个部分：

1. 链路控制协议（LCP）：用于建立、配置、测试和管理数据链路
2. 网络控制协议（NCP）：PPP协议允许同时采用多种网络层协议，每个不同的网络层协议要用一个相应的NCP来配置，为网络层协议建立和配置逻辑连接
3. 一个将IP数据包封装到串行链路的方法

![image-20230325111503448](https://raw.githubusercontent.com/rowenci/ImagePool/main/img/typoraimage-20230325111503448.png)

#### HDLC协议

高级数据链路控制协议是面向比特的数据链路层协议。

### 数据链路层设备

网桥、局域网交换机（多接口网桥）

## 网络层

设计思路：向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务。

## 从输入URL按下回车到网页显示，期间发生了什么？

1. 浏览器首先需要对URL进行解析

   一个URL当中包含如下元素：

   1. 访问的协议
   2. 服务器地址
   3. 数据源的路径名

   如果只有1、2时，就会访问服务器根目录下的默认文件：index.html或default.html

   随后，浏览器根据URL生成HTTP请求报文

2. 浏览器委托操作系统将报文发送给服务器

   在报文发送之前，还需要将服务器地址（域名）进行DNS解析，解析过程为：

   1. 客户端向本地DNS服务器发送DNS请求，询问域名对应的IP是什么。（这一步当中使用的是递归查询，也就是客户端没有查找DNS的能力，则由本地DNS服务器进行查询，而不是让主机自己去查询）
   2. 本地DNS服务器接收到请求后，如果缓存当中没有对应IP，则会向根域名服务器查询。如果根域名服务器当中也没有对应的信息，则根域名服务器会告知本地DNS服务器，这个IP应该向哪个顶级域名服务器（如COM）进行查询。随后，本地域名服务器则会自己向根域名服务器进行查询。查询的结果返回给客户端（这一步当中使用的是迭代查询，也就是本地域名服务器向一个根域名服务器没有查询到后，会接着向另一个根域名服务器查询，请求发送者都是本地域名服务器）

   ![域名解析的工作流程](https://raw.githubusercontent.com/rowenci/ImagePool/main/img/typora6.jpg)

   当然，浏览器、操作系统、HOST文件当中都会有缓存啥的来记录域名-IP的对应。

3. 通过DNS获取到对应IP之后，就可以将HTTP的传输工作交给操作系统当中的协议栈。浏览器通过调用网络库来委托协议栈工作。

   ![img](https://raw.githubusercontent.com/rowenci/ImagePool/main/img/typora7.jpg)

4. 因为HTTP协议是基于传输层的TCP协议进行传输的，因此会将HTTP协议封装成TCP报文进行数据传输。

   在TCP报文当中，有以下比较重要的字段。

   1. 因为传输层负责端到端传输，因此需要有源端口号和目的端口号。

   2. 为了保证有序传输和可靠传输，需要有序号来表明当前TCP包的顺序，以及通信两端用的确认序号

   3. 三次握手、四次挥手用的各个字段

      三次握手过程如下：

      1. 连接建立之前，服务器会处于LISTEN状态，等待客户端连接。
      2. 客户端向服务器发送连接请求报文，该报文当中**SYN位**置1，同时选择一个初始序号seq = x。TCP规定SYN报文段不能携带数据，但需要消耗掉一个序号。此时客户端进入SYN_SENT（同步已发送）状态。**（第一次握手）**
      3. 服务器接收到TCP连接请求报文之后，如果同意建立连接，那么向客户端发送确认。同时为该TCP连接分配缓存和变量。在确认报文段当中，**SYN位**和**ACK位**都会被置1，确认号是ack = x + 1。同时也为自己选择一个初始序号seq = y。确认报文和SYN报文同样不能携带数据，且需要消耗一个序号。此时服务器进入SYN-RCVD（同步收到）状态。**（第二次握手）**
      4. 当客户端收到确认报文段后，还要向服务器发出确认报文，同时为该TCP连接分配缓存和变量。确认报文段当中**ACK位**置1，确认号ack = y + 1，序号 seq = x + 1。这个确认报文段可以携带数据。这时，客户端进入ESTABLISHED（已建立连接）状态。**（第三次握手）**

      ![image-20230327161529800](https://raw.githubusercontent.com/rowenci/ImagePool/main/img/typoraimage-20230327161529800.png)

      在上述三次握手成功之后，就建立了TCP连接，接下来可以传送应用层数据。TCP使用的是全双工通信。

      那么为什么TCP需要三次握手呢？

      1. 为了防止重复连接。如果只有两次的话，服务器无法判断这个连接是有效还是无效的，因为可能因为网络问题，客户端会发送两次连接请求。
      2. 同步双方初始序列号。由三次握手过程可知，为了有序传输，服务器和客户端有序号存在。三次握手才能让服务器拿到可靠的客户端序号。客户端接收到二次握手报文时，说明服务器确认了客户端的序号。服务端收到三次握手报文后，说明客户端确认了服务器的序号。
      3. 避免资源浪费。如果只有两次握手，服务器会为每一次连接请求都分配资源。

      服务器的资源是在完成第二次握手之后分配的，客户端则是完成第三次握手之后分配的。这就会使得服务器容易遭受SYN洪泛攻击。也就是服务器在第二次握手发出的确认报文可能永远也无法到达目的的，那么服务器在等待关闭这个TCP连接的过程中还是会消耗资源。因此，如果连接多了之后，服务器资源就会被耗尽。

      四次挥手过程如下：

      1. 客户端打算关闭连接时，向服务器发送连接释放报文，并停止发送数据，主动关闭连接。该报文当中**FIN位**置1，同样消耗序号seq = u。此时客户端进入FIN-WAIT-1（终止等待1）状态。因为是全双工通信，因此服务器还能发送数据过来。**（第一次挥手）**
      2. 服务器收到连接释放报文后，发送确认报文段，确认号ack = u + 1，序号seq = v，v等于前面已发送的数据序号加1.随后服务器进入CLOSE-WAIT（关闭等待）状态。此时，从客户端到服务器这个方向的连接就被释放了。TCP连接处于半关闭状态。但是服务器若要发送数据，客户端还是要接收。**（第二次挥手）**
      3. 若服务器没有要发送的数据时，就需要释放连接。此时，服务器会发送连接释放报文段，**FIN位**置1。设该报文段的序号为w（半关闭状态服务器也可能会发送一些数据给客户端），确认号为上次挥手发送的确认号ack = u + 1。这时，服务器进入LAST-ACK（最后确认）状态。**（第三次挥手）**
      4. 客户端收到连接释放报文后，必须发送确认。确认报文当中的**ACK位**置1。确认号ack = w + 1，序号weq = u + 1。注意这个阶段，如果服务器收到了这个阶段发送的确认报文后，会直接关闭连接。但客户端还需要等待2MSL（最长报文段寿命）后，客户端才会完全关闭。因为最后一个报文不确定有没有发送到服务器，如果没有的话，在2MSL时间段内一定会再次收到服务器的连接确认报文，这时客户端会重新进行确认报文的发送。**（第四次挥手）**

      ![image-20230327161540146](https://raw.githubusercontent.com/rowenci/ImagePool/main/img/typoraimage-20230327161540146.png)

      那么为什么需要四次挥手呢？

      ​	因为TCP是全双工模式，前两次挥手是客户端关闭连接，也就是TCP半关闭状态。后两次是服务器关闭连接，TCP完全关闭。

   4. 用于流量控制的窗口大小

      。。。。。。

5. TCP协议进行连接、传输、断开等操作时，都需要网络层的IP协议将TCP报文封装成IP数据报在网络上进行发送。

   IP协议负责的是点到点的传输，也就是从一个主机传输到另一个主机。两个主机通过IP进行标识。在网络当中进行传输时，需要通过路由器来进行路由，因此路由器也是工作在网络层的设备。


6. 当然，只通过IP是无法在数据链路上进行传输的，因此在数据链路层，需要将IP数据包封装成MAC帧来进行传输。

   这时问题就来了，因为上层IP协议头部只有IP地址，没有MAC地址，那么怎么才能在传输层工作呢？这个时候就需要用到ARP协议来将IP解析成为MAC地址。

   每台主机当中都有一个ARP告诉缓存，用来存放本地局域网当中各主机和路由器的IP到MAC的映射表。ARP协议工作原理如下：

   1. 查询ARP高速缓存，如果有直接用MAC地址。
   2. 如果没有，就使用目的MAC地址为全1（FF-FF-FF-FF-FF-FF）的帧来封装并广播ARP请求分组，使同一个局域网当中所有主机都接收到这个请求。如果主机B就是这个主机，那么就向主机A发送一个ARP响应分组，主机收到分组后，将映射写入ARP高速缓存。之后就使用这个缓存来进行通信。

   ARP欺骗。这个是针对ARP协议的一种攻击技术，通过欺骗局域网内的PC，让主机认为篡改后的MAC地址是网关地址，则会使主机将所有数据全部发送到篡改后的MAC当中。

   ARP欺骗亦有正当用途。其一是在一个需要登录的网上中，让未登录的计算机将其浏览网页强制转向到登录页面，以便登录后才可使用网上。另外有些设有备援机制的网上设备或服务器，亦需要利用ARP欺骗以在设备出现故障时将讯务导到备用的设备上。

7. 最后，MAC帧经过网卡，被发送到物理链路上进行传输。可能会经过局域网当中的交换机，以及网络当中的路由器。
   1. 交换机：数据链路层。多接口网桥。根据映射表转发。
   2. 路由器：网络层。有存储转发的功能。根据路由表来转发。

8. 数据传输到服务器后，会一层层删除首部。传输层因为是端到端，所以会根据端口号将数据传输到对应的进程，进行相应的逻辑操作：将浏览器请求的文件按照上述过程封装成HTTP协议并向下传输。
9. 在客户端收到HTTP响应报文后，将接收到的数据交给浏览器进行页面的渲染，最终显示成为页面。

![网络分层模型](https://raw.githubusercontent.com/rowenci/ImagePool/main/img/typora25.jpg)

## HTTP协议

Hypertext Transfer Protocol 超文本传输协议

![ 五大类 HTTP 状态码 ](https://raw.githubusercontent.com/rowenci/ImagePool/main/img/typora6-%25E4%25BA%2594%25E5%25A4%25A7%25E7%25B1%25BBHTTP%25E7%258A%25B6%25E6%2580%2581%25E7%25A0%2581.png)