## 字母异位词分组

解法：排序后哈希

```c++
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        // 遍历时，将每个单词的备份先排序，再用排序后的单词作为key，插入到map当中
        vector<vector<string>> res;
        unordered_map<string, vector<string>> backMap;
        for(auto& str : strs){
            string temp = str;
            sort(temp.begin(), temp.end());
            backMap[temp].push_back(str);
        }
        for(auto& it : backMap){
            res.push_back(std::move(it.second));
        }
        return res;
    }
};
```

## 最长连续序列

解法：先用unordered_set去重，去重完成之后遍历。

遍历就是找这个数的前一个有没有在里面，如果在里面，就说明有连续的，就while

如果不在里面，就找下一个

为什么for里面有个while，却还是o(n)？

以5 100 4 3 2 1为例。

如果当前元素-1在哈希表里面，那么这个元素就直接过掉了，如果不在里面，如，100，这时候会直接更新count为1。

但是如果是1的话，因为0不在里面，所以会进入while循环。直到找完所有的连续数。

综上，只有当一个数是连续序列的第一个数的情况下才会进入内层循环，然后在内层循环中匹配连续序列中的数，因此数组中的每个数只会进入内层循环一次。所以，时间复杂度是0(n)。严格来说是2n。

```c++
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        unordered_set<int> uset(nums.begin(), nums.end());
        int res = 0;
        for(auto num : nums){
            int count = 1;
            if(!uset.count(num - 1)){
                while(uset.count(++num)){
                    ++count;
                }
            }
            res = max(res, count);
        }
        return res;
    }
};
```

## 移动零

解法：慢指针：记录当前非0元素应该放的位置。快指针：遍历数组

```c++
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int slow = 0;
        for(int fast = 0; fast < nums.size(); fast++){
            if(nums[fast] != 0){
                int temp = nums[slow];
                nums[slow] = nums[fast];
                nums[fast] = temp;
                ++slow;
            }
        }
    }
};
```

## 盛最多水的容器

解法：从两头往中间遍历。

一般是要找更长的那一块板子，因此，哪边更短，哪边就往中间移动

```c++
class Solution {
public:
    int maxArea(vector<int>& height) {
        int i = 0;
        int j = height.size() - 1;
        int res = 0;
        while(i < j){
            res = height[i] < height[j] ?
                    max(res, (j - i) * height[i++]):
                    max(res, (j - i) * height[j--]);
        }
        return res;
    }
};
```

## 三数之和

解法：因为不允许有重复数组，所以先进行排序。排序完成后确定第一个数，随后将剩下两个数的查找转化为两数之和

```c++
class Solution {
public:
    // value：第一个数
    vector<vector<int>> twoSum(vector<int>& nums, int start, int end, int target, int value){
        vector<vector<int>> answer;
        while(start < end){
            int sum = nums[start] + nums[end];
            if(sum == target){
                vector<int> result;
                result.push_back(value);
                result.push_back(nums[start]);
                result.push_back(nums[end]);
                answer.push_back(result);

                while(start < end && nums[start] == nums[start + 1])
                    start++;
                start++;

                while(start < end && nums[end] == nums[end - 1])
                    end--;
                end--;
            }else if(sum < target){
                start++;
            }else{
                end--;
            }
        }
        return answer;
    }
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> res;
        // 排序
        sort(nums.begin(), nums.end());
        for(int i = 0; i < nums.size(); i++){
            if(i > 0 && nums[i] == nums[i - 1])
                continue;
            // 转化成两数之和
            auto result = twoSum(nums, i + 1, nums.size() - 1, -nums[i], nums[i]);
            res.insert(res.end(), result.begin(), result.end());
        }
        return res;
    }
};
```

