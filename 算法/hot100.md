## 题目
### 字母异位词分组

解法：排序后哈希

```c++
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        // 遍历时，将每个单词的备份先排序，再用排序后的单词作为key，插入到map当中
        vector<vector<string>> res;
        unordered_map<string, vector<string>> backMap;
        for(auto& str : strs){
            string temp = str;
            sort(temp.begin(), temp.end());
            backMap[temp].push_back(str);
        }
        for(auto& it : backMap){
            res.push_back(std::move(it.second));
        }
        return res;
    }
};
```

### 最长连续序列

解法：先用unordered_set去重，去重完成之后遍历。

遍历就是找这个数的前一个有没有在里面，如果在里面，就说明有连续的，就while

如果不在里面，就找下一个

为什么for里面有个while，却还是o(n)？

以5 100 4 3 2 1为例。

如果当前元素-1在哈希表里面，那么这个元素就直接过掉了，如果不在里面，如，100，这时候会直接更新count为1。

但是如果是1的话，因为0不在里面，所以会进入while循环。直到找完所有的连续数。

综上，只有当一个数是连续序列的第一个数的情况下才会进入内层循环，然后在内层循环中匹配连续序列中的数，因此数组中的每个数只会进入内层循环一次。所以，时间复杂度是0(n)。严格来说是2n。

```c++
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        unordered_set<int> uset(nums.begin(), nums.end());
        int res = 0;
        for(auto num : nums){
            int count = 1;
            if(!uset.count(num - 1)){
                while(uset.count(++num)){
                    ++count;
                }
            }
            res = max(res, count);
        }
        return res;
    }
};
```

### 移动零

解法：慢指针：记录当前非0元素应该放的位置。快指针：遍历数组

```c++
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int slow = 0;
        for(int fast = 0; fast < nums.size(); fast++){
            if(nums[fast] != 0){
                int temp = nums[slow];
                nums[slow] = nums[fast];
                nums[fast] = temp;
                ++slow;
            }
        }
    }
};
```

### 盛最多水的容器

解法：从两头往中间遍历。

一般是要找更长的那一块板子，因此，哪边更短，哪边就往中间移动

```c++
class Solution {
public:
    int maxArea(vector<int>& height) {
        int i = 0;
        int j = height.size() - 1;
        int res = 0;
        while(i < j){
            res = height[i] < height[j] ?
                    max(res, (j - i) * height[i++]):
                    max(res, (j - i) * height[j--]);
        }
        return res;
    }
};
```

### 三数之和

解法：因为不允许有重复数组，所以先进行排序。排序完成后确定第一个数，随后将剩下两个数的查找转化为两数之和

```c++
class Solution {
public:
    // value：第一个数
    vector<vector<int>> twoSum(vector<int>& nums, int start, int end, int target, int value){
        vector<vector<int>> answer;
        while(start < end){
            int sum = nums[start] + nums[end];
            if(sum == target){
                vector<int> result;
                result.push_back(value);
                result.push_back(nums[start]);
                result.push_back(nums[end]);
                answer.push_back(result);

                while(start < end && nums[start] == nums[start + 1])
                    start++;
                start++;

                while(start < end && nums[end] == nums[end - 1])
                    end--;
                end--;
            }else if(sum < target){
                start++;
            }else{
                end--;
            }
        }
        return answer;
    }
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> res;
        // 排序
        sort(nums.begin(), nums.end());
        for(int i = 0; i < nums.size(); i++){
            if(i > 0 && nums[i] == nums[i - 1])
                continue;
            // 转化成两数之和
            auto result = twoSum(nums, i + 1, nums.size() - 1, -nums[i], nums[i]);
            res.insert(res.end(), result.begin(), result.end());
        }
        return res;
    }
};
```

### 无重复的最长子串

解法：滑动窗口，并使用unordered_set进行重复字符判断。两个指针，窗口左边界和右边界。

如果没有重复，则进入set当中，fast往右移动。

如果有重复，说明这个时候这个左边界的滑动窗口已经到最大了，需要往右移动左边界，重新进行滑动窗口的判断。

```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        unordered_set<char> uset;
        int fast = 0;
        int res = 0;
        for(int i = 0; i < s.size(); i++){
            if(i != 0)
                uset.erase(s[i - 1]);
            while(fast < s.size() && !uset.count(s[fast])){
                uset.insert(s[fast]);
                fast++;
            }
            // fast is not in window, so the number should - 1 (fast - i + 1  >> fast - i)
            res = max(res, fast - i);
        }
        return res;
    }
};
```

### 找到字符串中所有字母异位词

解法：因为目标字符串中可能有相同字符，所以不能使用unordered_map

直接使用vector作为哈希表。

创建两个哈希表，分别存放s和p的字符。p先初始化，用s在遍历的时候将对应字符++。在重置的时候不需要重置所有的元素，只需要将窗口左边界的元素--就行。

```c++
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        int n = s.size(), m = p.size();
        if (n < m) return {};
        vector<int> smap(26);
        vector<int> pmap(26);
        for(auto& c : p) {
            pmap[c - 'a']++;
        }
        vector<int> ans;
        for(int i = 0; i < n; i++) {
            smap[s[i] - 'a']++;
            if(i >= m - 1) { // 当前的smap中元素已经达到m个
                if(pmap == smap)
                    ans.push_back(i - m + 1);
                smap[s[i - m + 1] - 'a']--; // 只删掉窗口左边界的元素
            }
        }
        return ans;
    }
};
```

### 合并区间

解法：首先进行排序，让区间从小到大排列

随后遍历，取每个区间的左右端点

如果当前区间与res的最后一个区间不重合（或res为空），则进行存储。

否则，说明当前区间与res内的最后一个数组有重合的部分，这时候就需要更新res的最后一个数组的右端点，值为right和右区间更大的那个。

```c++
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        if(intervals.size() == 0)
            return {};
        sort(intervals.begin(), intervals.end());
        vector<vector<int>> res;
        for(int i = 0; i < intervals.size(); i++){
            int left = intervals[i][0], right = intervals[i][1];
            if(!res.size() || res.back()[1] < left)
                res.push_back({left, right});
            else
                res.back()[1] = max(res.back()[1], right);
        }
        return res;
    }
};
```

### 除自身以外数组的乘积

解法：使用两个辅助数组left，right

第一次遍历填充left数组，left数组存储nums[i]左边的所有数的乘积left[i] = nums[i - 1] * left[i - 1]

第二次遍历填充right数组，right数组存储nums[i]右边的所有数的乘积right[i] = nums[i + 1] * right[i + 1]

第三遍遍历填充结果数组，用left[i] * right[i]，表示nums[i]左边和右边的所有数的乘积（不包括i）

```c++
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        vector<int> left(nums.size(), 0), right(nums.size(), 0);
        vector<int> res(nums.size());
        left[0] = 1;
        for(int i = 1; i < nums.size(); i++)
            left[i] = nums[i - 1] * left[i - 1];
        right[nums.size() - 1] = 1;
        for(int i = nums.size() - 2; i >= 0; i--)
            right[i] = nums[i + 1] * right[i + 1];
        for(int i = 0; i < nums.size(); i++)
            res[i] = left[i] * right[i];
        return res;
    }
};
```

### 矩阵置零

解法：两个辅助数组，分别记录0元素所在的行、列

第二次遍历，置零

```c++
class Solution {
public:
    void setZeroes(vector<vector<int>>& matrix) {
        int m = matrix.size();
        int n = matrix[0].size();
        vector<bool> row(m), col(n);
        for(int i = 0; i < m; i++){
            for(int j = 0; j < n; j++){
                if(!matrix[i][j]){
                    row[i] = col[j] = true;
                }
            }
        }

        for(int i = 0; i < m; i++){
            for(int j = 0; j < n; j++){
                if(row[i] || col[j]){
                    matrix[i][j] = 0;
                }
            }
        }
    }
};
```

## 解题方法

### 数组

记住数组特性就行了

空间连续，查找快，增删慢

### 链表

头结点：链表的入口节点。头指针指向头结点（链表的第一个结点），该结点有值

空间不连续，查找慢，增删快

头插法得到的链表与插入顺序相反，可以用来对链表进行翻转

### 哈希表

哈希表根据key来插入和查找。

数组也可以成为一个哈希表，只要能将元素和数组下标结合起来（通过哈希函数）。

在c++当中，有三个数据结构可以用来当做哈希表：数组、unordered_set、unordered_map

数组做哈希表的限制：1. 大小有限；2. 若数组大小足够大，但哈希值少，则空间浪费。

set做哈希表的限制：1. 只能存放一个key；
